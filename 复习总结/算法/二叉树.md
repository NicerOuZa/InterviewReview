# 一、二叉树的遍历
## 1. 先序遍历二叉树（NLR）
- 先访问根节点
- 先序遍历左子树
- 先序遍历右子树
```java
public class BTNode {
	//简化方式
	public int data = 0;
	public BTNode lchild = null;
	public BTNode rchild = null;
}
//递归
public void preOrder(BTNode bt) {
	if(bt != null) {
		System.out.println("data" + bt.data);
		preOrder(bt.lchild);
		preOrder(bt.rchild);
	}
}
//非递归
if (当前b树不空)
{
　    根结点b进;
      while (栈不栈空)
      {
           出栈结点p并访问之;
           若p结点有右孩子，将其右孩子进栈； 
           若p结点有左孩子，将其左孩子进栈；
       }
}
```

## 2. 中序遍历二叉树（LNR）
- 中序遍历左子树
- 访问根节点
- 中序遍历右子树
```java
//递归
public void inOrder(BTNode bt) {
	if(bt != null) {
		inOrder(bt.lchild);
		System.out.println("data" + bt.data);
		inOrder(bt.rchild);
	}
}

//非递归
p＝b;
while (栈不空或者p!=NULL)
{
       while (p!=NULL)
       {     将p进栈；
               p=p->lchild;
        }
        //以下考虑栈顶结点
       if (栈不空) 
       {      出栈p并访问之；
　　       p＝p->rchild;
        }
}
```

## 3. 后序遍历二叉树（LRN）
- 后序遍历左子树
- 后序遍历右子树
- 访问根节点
```java
//递归
public void postOrder(BTNode bt) {
	if(bt != null) {
		postOrder(bt.lchild);
		postOrder(bt.rchild);
		System.out.println("data" + bt.data);
	}
}
//非递归
p=b;
do
{      while (结点p有左孩子)
        {	将结点p进栈;
	p=p->lchild;
         }
        //此时栈顶结点(尚未访问)没有左孩子或左子树已遍历过
        while (栈不空且结点p是栈顶结点)
        {	取栈顶结点p;
	if (结点p的右子树已访问)
	{      访问结点p;
	        退栈;
	}
	else p=p->rchild;     //转向处理其右子树
        }
} while (栈不空);
```