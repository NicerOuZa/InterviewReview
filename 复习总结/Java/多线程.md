[面试总结](https://github.com/frank-lam/fullstack-tutorial/blob/master/notes/JavaArchitecture/03-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.md#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97)
## 1. Java 中sleep与wait区别
1. 这两个方法来自不同的类分别是Thread和Object
2. 最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。
3. wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用（使用范围）
4. sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常
5. sleep是Thread类的静态方法。sleep的作用是让线程休眠制定的时间，在时间到达时恢复，也就是说sleep将在接到时间到达事件事恢复线程执行。wait是Object的方法，也就是说可以对任意一个对象调用wait方法，调用wait方法将会将调用者的线程挂起，直到其他线程调用同一个对象的notify方法才会重新激活调用者

## 2. 锁机制
简述为什么要有锁
实现锁的方式
1. **Synchronized**
2. **Volatile**
3. **Lock**
4. **ReentrantLock**
 - [底层原理](https://www.cnblogs.com/zhangfengshi/p/9203191.html)
5. **ReentrantReadWriteLock**

## 2. Lock原理

## 3. Synchronized 和 Lock 的区别？
参考：[区别1](https://www.jianshu.com/p/dd09194b120b)，[区别2](https://blog.csdn.net/xujiangdong1992/article/details/102857063)
1. 最简单的，Lock是一个接口，是在Java代码层面的；然后Synchronized是Java的一个关键字，是JVM层面的。
2. Synchronized在完成同步代码块后或是发生异常后自动释放锁；而Lock则是主动释放，最好在finally中释放，不然很容易造成死锁。
3. Lock可以绑定条件，实现分组唤醒需要的线程；synchronized要么随机唤醒一个，要么唤醒全部线程。

## 4. 可重入锁与不可重入锁
可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。

## 5. 锁的种类
参考：[Java锁的分类和使用](https://www.cnblogs.com/hustzzl/p/9343797.html)
1. **乐观锁**：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS(Compare and Swap 比较并交换)实现的。
2. **悲观锁**：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。比如Java里面的同步原语synchronized关键字的实现就是悲观锁。
3. **独享锁**：是指该锁一次只能被一个线程所持有。Java ReentrantLock而言，其是独享锁
4. **共享锁**：是指该锁可被多个线程所持有。Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。
5. **公平锁**：是指多个线程按照申请锁的顺序来获取锁。
6. **非公平锁**：是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。对于Synchronized而言，也是一种非公平锁。
- 下面三种锁是指锁的状态，并且是针对Synchronized
7. **偏向锁**：是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
8. **轻量级锁**：是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
9. **重量级锁**：是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让他申请的线程进入阻塞，性能降低。
10. **分段锁**：
11. **可重入锁**：可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。

## 6. 锁优化
1. **自旋锁:**
 1. 如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只须让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。
   - *注释：自旋锁在JDK 1.4.2中就已经引入，只不过默认是关闭的，可以使用-XX：+UseSpinning参数来开启，在JDK 6中就已经改为默认开启了。*
 2. 在JDK 6中对自旋锁的优化，引入了自适应的自旋。自适应意味着自旋的时间不再是固定的了 而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。
2. **锁消除:**锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。
3. **锁粗化:**
4. **轻量级锁:**轻量级锁是JDK 6时加入的新型锁机制。
5. **偏向锁:**偏向锁也是JDK 6中引入的一项锁优化措施，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能

## 7. 线程池的实现原理
 线程池就是首先创建一些线程，它们的集合称为线程池。使用线程池可以很好地提高性能，线程池在系统启动时即创建大量空闲的线程，程序将一个任务传给线程池，线程池就会启动一条线程来执行这个任务，执行结束以后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个任务。
- 如下图：
 ![](多线程_files/1.jpg)
 1. 线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。
 2. 线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。
 3. 线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。

- ThreadPoolExecutor执行execute方法分下面4种情况:
![](多线程_files/2.jpg)
 1. 如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。
 2. 如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。
 3. 如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。
 4. 如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。

## 8. Java中有几种线程池？
参考博客：[常见线程池](https://www.cnblogs.com/jiawen010/p/11855768.html)
1. 线程池的返回值ExecutorService简介：
    ExecutorService是Java提供的用于管理线程池的类。**该类的两个作用：控制线程数量和重用线程**。
2. 具体的4种常用的线程池实现如下：（返回值都是ExecutorService）
    1. **Executors.newCacheThreadPool()**：可缓存线程池，先查看池中有没有以前建立的线程，如果有，就直接使用。如果没有，就建一个新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务。
	2. **Executors.newFixedThreadPool(int n)**：创建一个可重用固定个数的线程池，以共享的无界队列方式来运行这些线程。
	3. **Executors.newScheduledThreadPool(int n)**：创建一个定长线程池，支持定时及周期性任务执行
	4. **Executors.newSingleThreadExecutor()**：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

## 9. 线程池有什么好处？
1. 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
2. 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能执行。
3. 提高线程的可管理性，线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控。

## 10. 并发编程的挑战和解决方案？
1. **上下文切换：**
 - 定义：CPU通过给每个线程分配CPU时间片来实现多线程，任务从保存到再加载的过程就是一次上下文切换。*类似看书途中去翻字典*。
 - 减少上下文切换的方法有**无锁并发编程**、**CAS算法**、**使用最少线程**和**使用协程**。
  - **无锁并发编程**:多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。
  - **CAS算法**: Java的Atomic包使用CAS算法来更新数据，而不需要加锁。
	- CAS（Compare and Swap 比较并交换），当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。
　　CAS操作中包含三个操作数——需要读写的内存位置(V)、进行比较的预期原值(A)和拟写入的新值(B)。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B，否则处理器不做任何操作。
  - **使用最少线程**: 避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。
  - **协程**：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。
2. **死锁：**
 - 避免死锁的几个常见方法：
  - 避免一个线程同时获取多个锁
  - 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。
  - 尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。
  - 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。  
3. **资源限制的挑战：**
 - 资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。例如网速

## 11. Java并发编程的底层原理
Java代码在编译后会变成Java字节码，字节码被类加载器加载到JVM里，JVM执行字节
码，最终需要转化为汇编指令在CPU上执行，Java中所使用的并发机制依赖于JVM的实现和
CPU的指令。
1. **volatile的应用：**它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。
 	- **volatile原理：**由有volatile修饰的变量汇编代码中会多出**Lock**前缀的指令。
 	 1. Lock前缀指令会引起处理器缓存回写到内存。
 	 2. 一个处理器的缓存回写到内存会导致其他处理器的缓存无效。
	- **volatile的使用优化：**与处理器有关。
2. **synchronized的原理与应用：**
Java SE 1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。 
	- synchronized基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式：
	 1. 对于普通同步方法，锁是当前实例对象；
	 2. 对于静态同步方法，锁是当前类的Class对象；
	 3. 对于同步方法块，锁是Synchonized括号里配置的对象。
    - 当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。那么锁到底存在哪里呢？锁里面会存储什么信息呢？

## 12. 线程安全的实现方法
1. **互斥同步**：互斥量、临界区、信号量， 最基本的互斥同步手段就是synchronized关键字。
2. **非阻塞同步：**基于冲突检测的乐观并发策略， 通俗地说就是不管风险，先进行操作，如果没有其他线程争用共享数据，那操作就直接成功了；如果共享的数据的确被争用， 产生了冲突，那再进行其他的补偿措施，最常用的补偿措施是不断地重试，直到出现没有竞争的共享数据为止。依靠硬件来保证原子性，通过处理器指令就能完成：
	1. 测试并设置（Test-and-Set）；
	2. 获取并增加（Fetch-and-Increment）；
	3. 交换（Swap）；
	4. **比较并交换（Compare-and-Swap， 下文称CAS）**；
		- CAS指令需要有三个操作数， 分别是内存位置（在Java中可以简单地理解为变量的内存地址，用V表示）、旧的预期值（用A表示） 和准备设置的新值（用B表示）。CAS指令执行时，当且仅当V符合A时，处理器才会用B更新V的值，否则它就不执行更新。但是，不管是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作，执行期间不会被其他线程中断。
		- *备注：在JDK 5之后，Java类库中才有CAS操作，通过其他方法包装提供。直到JDK 9之后，Java类库才在VarHandle类里开放了面向用户程序使用的CAS操作。*
	5. 加载链接/条件储存（Load-Linked/Store-Conditional， 下文称LL/SC） 。 
3. **无同步方案：**
	1. **可重入代码（Reentrant Code）：** 
		1. 可重入代码（Reentrant Code）：这种代码又称纯代码（Pure Code），是指可以在代码执行的任何时刻中断它， 转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误， 也不会对结果有所影响。
		2. 可重入代码有一些共同的特征，例如，<u>*不依赖全局变量*、*存储在堆上的数据和公用的系统资源*，*用到的状态量都由参数中传入*， *不调用非可重入的方法*等</u>。
	2.**线程本地存储：**
		1. 线程本地存储（Thread Local Storage）：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。



## 13. ThreadLocal原理分析

## 14. Runnable、Callable、Future的区别和联系
1. **Runnable**<br />
Runnable应该是我们最熟悉的接口，它只有一个run()函数，用于将耗时操作写在其中，该函数没有返回值。然后使用某个线程去执行该runnable即可实现多线程，Thread类在调用start()函数后就是执行的是Runnable的run()函数。

2. **Callable**<br />
Callable与Runnable的功能大致相似，Callable中有一个call()函数，但是call()函数有返回值，而Runnable的run()函数不能将结果返回给客户程序。
```java
public interface Callable<V> {
    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */
    V call() throws Exception;
}
```
可以看到，这是一个泛型接口，call()函数返回的类型就是客户程序传递进来的V类型。

3. **Future**<br />
Executor就是Runnable和Callable的调度容器，Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果、设置结果操作。get方法会阻塞，直到任务返回结果
<br />
FutureTask是一个RunnableFuture<V>
<br />
RunnableFuture实现了Runnbale又实现了Futrue<V>这两个接口

4. **Callable 和 Runnable接口的区别**

 - Callable规定的方法是call()，而Runnable规定的方法是run(). 
 - Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。  
 - call()方法可抛出异常，而run()方法是不能抛出异常的。 
 - 运行Callable任务可拿到一个Future对象， Future表示异步计算的结果。 
 - 它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。 
 - 通过Future对象可了解任务执行情况，可取消任务的执行，还可获取任务执行的结果。 
 - Callable是类似于Runnable的接口，实现Callable接口的类和实现Runnable的类都是可被其它线程执行的任务。